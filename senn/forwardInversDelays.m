
% Forward-Inverse sequence learning, from Richard Hahnloser, received Nov 13, 2010. 
% Adapted by ws to include delays and taylored to the suggest scheme.

clear all
nsong=50; % dimension of song
nu=50; % number of motor neurons
ny=50; % number of sensory neurons
tau=10; % 10 Delay of sensory signal with respect to the generating motor signa (syrinx + auditory pathway), Richard's case: =0
oneStep=1; % Delay of one neuronal step, Richard's case: =0   
nlearn=100; % learning steps
T=200; % duration of song, Richard's case: =1 

U=randn(nsong,nu)/sqrt(nu); % syrinx; converts the motor activity signal u into a song
ud=randn(nu,T); % motor activity to generate father song

Y=randn(ny,nu)/sqrt(ny); % auditory pathway; converts the song into a sensory signal y
tut_song=delay(U*ud,oneStep);
yd=delay(Y*tut_song,tau);  % sensory signal generated by the tutor song
%yd=.2*ones(ny,1);

m=randn(nu,ny)/sqrt(nu); % weight matrix converting the sensory signal y into a motor signal u (invers model)
f=randn(ny,nu); % weight matrix converting the motor signal into a sensory signal (forward model)

eta=0.001; % learning rate
e=zeros(1,nlearn);
S=Y*U; % Total motor to sensory transformation

%% learn forward model by random song practicing and predicting the sensory signal from the motor activity
for i=1:nlearn
    u=randn(nu,T); % generate motor sequence 
    y=delay(S*u,tau); % sensory response delayed by tau time steps
    fu=delay(f*u,oneStep); % forward signal (tilde s) in the sensory area
    dy=(y-delay(fu,tau-oneStep)); % estimation error
    df = dy*delay(u,tau)'; % Learning rule for the forward weights
    f=f+eta*df; % update of forward weights
    e(i)=sum(sum(dy.*dy))/(T*ny); % Mean square error in sensory estimation per time step and sensory neuron
end
figure(1);clf;plot(e); xlabel('learning steps'); ylabel('Forward error');

%% learn the inverse model by dreaming random motor patterns and reproducing these based on the forwardly generated sensory activity
eta2=0.001;
e2=zeros(1,nlearn);
for i=1:nlearn
    u=randn(nu,T); % dreamed motor activity
    y2=delay(f*u,oneStep); % self-generated sensory activity by the forward model 
    u2=delay(m*y2,oneStep); % motor activity predicted from the self-generated sensory activity
    du=(delay(u,2*oneStep)-u2); % estimation error
    dm=du*delay(y2,oneStep)'; % learning rule for inverse weights
    m=m+eta2*dm; % update inverse weights
    e2(i)=sum(sum(du.*du))/(T*nu); % Mean square error in motor estimation per time step and motor neuron
end

figure(2);clf;plot(e2); xlabel('learning steps'); ylabel('Inverse error');

%% Test whether memory of tutor song generates the original song via motor activiy generated by the inverse model
u=delay(m*yd,oneStep); % Convert the memorized tutor song yd into motor command u
ypred=delay(S*u,tau); % Sensory signal generated from the memory of father's song

i=randint(1,1,[1,ny]); % Select a sensory neuron
ydd=delay(yd,tau+1); % Delay the memory of the tutor song by the time it needs to generate the sensory feedback
figure(3);clf; plot(ypred(i,:),'k');hold on;plot(ydd(i,:),'r');
xlabel('time steps'); ylabel('Activity of one sensory neurons');
legend('ypred','yd');
[r,p]=corrcoef(ydd(:),ypred(:));
fprintf('Corr. coeff: %.4f\n',r(1,2));
